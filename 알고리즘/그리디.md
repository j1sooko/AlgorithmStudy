# 그리디(Greedy algorithm)
- 선택할 때마다 그 순간에 최적이라고 생각되는 것들을 선택해나감으로써 최종적인 해답에 도달하는 방법
- 그 답이 최적이라는 보장 없음. 검증이 필요하며, '근사한 값'을 목표로 함

## 조건
대부분 두가지 조건이 만족될 때 그리디 알고리즘 적용 가능
1. 탐욕 선택 속성(greedy choice property): 앞의 선택이 이후의 선택에 영향을 주지 않음
2. 최적 부분 구조(optimal substructure): 문제에 대한 최적해가 부분 문제에 대해서도 최적해

## 단계
1. 문제의 최적해 구조 결정
2. 문제의 구조에 맞게 선택 절차 정의 -> Selection Procedure(선택 절차)
3. 선택 절차에 따라 선택 수행
4. 선택된 해가 문제의 조건을 만족하는 지 검사 -> Feasibility Check(적절성 검사)
5. 조건을 만족하지 않으면 해당 해 제외
6. 모든 선택이 완료되면 해답 검사 -> Solution Check(해답 검사)
7. 조건을 만족하지 않으면 해답으로 인정하지 않음


## 예시
1. 거스름돈
[ 동전의 개수가 최소가 되도록 거스름 돈을 계산 ]
- 가치가 높은 동전부터 선택(선택 절차)
- 선택한 동전의 가치가 목표로 하는 가치보다 크다면 다음으로 작은 동전 선택(적절성 검사)
- 총액이 일치한다면 문제 해결(해답 검사)

최적의 해가 보장되는 이유는, 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없음

## 최적의 해가 보장되는 대표적인 알고리즘
### Kruskal과 Prim 알고리즘
- 신장 트리(Spanning tree): 그래프의 모든 정점을 포함하는 트리(사이클이 없음). n개의 정점을 가지는 그래프의 신장 트리는 n-1개의 간선을 가짐
- 최소 비용 신장 트리(MST: Minimum Spannig Tree): 모든 정점들을 가장 적은 수의 간선과 비용으로 연결
- sparse graph(간선이 적은 그래프)는 크루스칼 알고리즘, dense graph(간선이 많은 그래프)에는 프림 알고리즘이 유리함
- 
#### 1. Kruskal의 MST 알고리즘
1. 모든 간선을 가중치를 기준으로 오름차순 정렬
2. 최소 비용 간선 (u, v)를 선택하여 사이클 발생 유무 확인
   정점 u와 정점 v가 서로 다른 집합에 속하면 하나로 만든다.
   - 발생할 경우: MST에 포함하지 않음
   - 발생하지 않는 경우: MST에 포함
3. 모든 간선에 대해 2를 반복
   
- 시간 복잡도: O(|E|log|E|)
- 유니온 파인드 사용
  
![image](https://github.com/j1sooko/AlgorithmStudy/assets/70093771/f04eb75d-3604-4fe6-89b1-fc0ae2ed49c8)

#### 2. Prim 알고리즘
1. 시작 정점을 방문 후, 집합에 추가
2. 집합에 연결된 간선 중 낮은 가중치 정점 선택
   -> 선택한 정점 방문 후, 집합에 추가
3. 2의 과정을 트리가 (n-1)개의 간선을 가질 때까지 반복
   
- 시간 복잡도:  우선순위큐 사용 O(|E|log|V|), 배열 사용 O(V²)

![image](https://github.com/j1sooko/AlgorithmStudy/assets/70093771/d4c04b73-1f62-41b8-9551-d0a04a8dc53b)


