# 정렬

## 선택 정렬
- 각 루프마다
  1. 최대 원소를 찾음
  2. 최대 원소와 맨 오른쪽 원소를 교환함
  3. 맨 오른쪽 원소를 제외함
  하나의 원소만 남을 때까지 위의 루프를 반복함

- 시간복잡도: O(n²)

```
selectionSort[A[], n)
{
  for last ← n downto 2
    A[1...last] 중 가장 큰 수 A[k]를 찾는다;
    A[k] ↔ A[last];  // A[k]와 A[last]의 값을 교환
}

```

## 버블정렬
- 인접한 두 수를 비교하여 오름차순이나 내림차순으로 정렬함
- 시간복잡도: O(n²)
```
bubbleSort[A[], n)
{
  for last ← n downto 2
    for i ← 1 to last - 1 //하나씩 제외하면서 
      if (A[i] > A[i + 1]) then A[i] ↔ A[i + 1]; // 교환
}

```

## 삽입정렬
- 인접한 두 수를 비교하여 오름차순이나 내림차순으로 정렬함
- 시간복잡도: 최악의 경우에 O(n²), 이미 정렬되어있다면 O(n)
```
insertionSort[A[], n)
{
  for i ← 2 to n
    A[1 ... i]의 적당한 자리에 A[i]를 삽입한다
}

```

```
insertionSort(int* A, n)
{
  int i; 

  for (i = 1; i < n; i++) // n - 1회 동안
  {  int j = 0; int m, k;
      for (j = 0; j < i; j++) // 위치 찾기
        if(A[j] > A[i]) break;
      m = A[i]; // 삽입하고자 하는 값을 m에 copy해두기

      for (k = i; k > j; k--) // 자리 옮겨주기(뒤에서부터)
        A[k] = A[k - 1];

      A[j] = m;
  }
}
```


## 버블정렬
- 인접한 두 수를 비교하여 오름차순이나 내림차순으로 정렬함
- 시간복잡도: O(n²)
```
bubbleSort(A[], n)
{
  for last ← n downto 2
    for i ← 1 to last - 1 //하나씩 제외하면서 
      if (A[i] > A[i + 1]) then A[i] ↔ A[i + 1]; // 교환
}

```

## 분할정복법 - 합병정렬
- 1. 배열을 반으로 나눔
  2. 각각을 순환적으로 정렬
  3. 정렬된 두 배열을 합침
     
- 시간복잡도: O(nlogn)
  
```
mergeSort(A[], p, r)
{
  if (p < r) then {
    q ← (p + r) / 2; // p, q의 중간
    mergeSort(A, p, q);
    mergeSort(A, p, q);
    merge(A, p, q, r); // 합병
  }
}

merge(A[], p, r)
{
  정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합하여
  정렬된 하나의 배열 A[p...r]을 만든다
}
```


## 분할정복법 - 퀵 정렬
- 1. 배열의 마지막 수를 기준(pivot)으로 삼음
  2. pivot보다 작은 수는 왼쪽에, 나머지는 오른쪽에 재배치(분할)
  3. pivot의 왼쪽과 오른쪽을 순환적으로 정렬
     
- 시간복잡도: O(nlogn)
  
```
mergeSort(A[], p, r)
{
  if (p < r) then {
    q ← (p + r) / 2; // p, q의 중간
    mergeSort(A, p, q);
    mergeSort(A, p, q);
    merge(A, p, q, r); // 합병
  }
}

merge(A[], p, r)
{
  정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합하여
  정렬된 하나의 배열 A[p...r]을 만든다
}
```
  
